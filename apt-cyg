#!/usr/bin/env bash

# apt-cyg: install tool for cygwin similar to debian apt-get

# The MIT License (MIT)
# 
# Copyright (c) 2013 Trans-code Design
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# 

TRUSTEDKEYS=( CYGWIN CYGWINPORTS );
# ./cygwin.pub
# ------------
# pub   1024D/676041BA 2008-06-13
# uid                  Cygwin <cygwin@cygwin.com>
# sub   1024g/A1DB7B5C 2008-06-13
TRUSTEDKEY_CYGWIN_MD5="8fe5366fc82289578ab9b6e3c9f1bff9"
TRUSTEDKEY_CYGWIN_FPR="1169DF9F22734F743AA59232A9A262FF676041BA"
TRUSTEDKEY_CYGWIN_URL="https://sourceware.org/cgi-bin/cvsweb.cgi/~checkout~/setup/cygwin.pub?rev=2.1&cvsroot=cygwin-apps"
TRUSTEDKEY_CYGWIN_URL_LATEST="https://sourceware.org/cgi-bin/cvsweb.cgi/~checkout~/setup/cygwin.pub?cvsroot=cygwin-apps"
# ./ports.gpg
# -----------
# pub   1024D/66EE1F94 2008-10-27
# uid                  Yaakov Selkowitz (Cygwin Ports) <yselkowitz@users.sourceforge.net>
# sub   4096g/7D66B0D2 2008-10-27
TRUSTEDKEY_CYGWINPORTS_MD5="4c7904807340411f48f7519173cd600d"
TRUSTEDKEY_CYGWINPORTS_FPR="45600BB98CA878AA97A70119FF20AF9A66EE1F94"
TRUSTEDKEY_CYGWINPORTS_URL_LATEST="http://cygwinports.org/ports.gpg"

__check_deps () {
  for dep in $apt_cyg_DEPS; do
    if ! command -v "$dep" >/dev/null 2>&1; then
      [ -z "$FDEPS" ] && FDEPS="$dep" || FDEPS="${FDEPS} $dep"
    fi
  done
  [ -n "$FDEPS" ] && return 1
  return 0
}

__deps_helper () {
  local arch="$(current_cygarch)"
  local rootp="$(cygpath -wa /)"
  local fdeps="$(printf "%s$FDEPS" | sed 's/\ /\,/g')"
  printf "%sError: Missing dependencies = $FDEPS\nTry resolving dependencies using Cygwin setup/installer executable\nExample /path/to/setup-$arch.exe --download --root $rootp --wait --no-shortcuts --packages $fdeps "
}

# this script requires some packages
apt_cyg_DEPS="wget tar awk gpgv gpg"

__check_deps || { printf "%sError: Missing dependencies = $FDEPS"; exit 1; }

usage () {
  printf "%sapt-cyg: Installs and removes Cygwin packages.
apt-cyg install <package names> to install packages
apt-cyg remove <package names> to remove packages
apt-cyg update to update setup.ini
apt-cyg show to show installed packages
apt-cyg find <patterns> to find packages matching patterns
apt-cyg describe <patterns> to describe packages matching patterns
apt-cyg packageof <commands or files> to locate parent packages
apt-cyg pathof <cache|mirror|mirrordir|cache/mirrordir|setup.ini> to show path
apt-cyg key-add <files> ... to add keys contained in <files>
apt-cyg key-del <keyids> ... to remove keys <keyids>
apt-cyg key-list to list keys
apt-cyg key-finger to list fingerprints
apt-cyg upgrade-self to upgrade apt-cyg
apt-cyg depends <package names>
       to show forward dependency information for packages with depth.
apt-cyg rdepends <package names>
       to show reverse dependency information for packages with depth.
apt-cyg completion-install to install completion.
apt-cyg completion-uninstall to uninstall completion.
apt-cyg mirrors-list to show list of mirros.
apt-cyg benchmark-mirrors <url> ... to benchmark mirrors.
apt-cyg benchmark-parallel-mirrors <url> ... to benchmark mirrors in parallel.
apt-cyg benchmark-parallel-mirrors-list to benchmark mirrors-list in parallel.
Options:
--charch <arch>          : change archetecture
--use-setuprc            : set cache and mirror with /etc/setup/setup.rc
--ignore-case, -i        : ignore case distinctions for <patterns>
--force-remove           : force remove
--force-fetch-trustedkeys: force fetch trustedkeys
--no-verify, -X          : Don't verify setup.ini signatures
--no-check-certificate   : Don't validate the server's certificate
--proxy, -p <auto|inherit|none|URL> :
                           set proxy (default: \${APT_CYG_PROXY:-auto})
--completion-get-subcommand:
                           get subcommand (for completion internal use)
--completion-disable-autoupdate:
                           disable completion autoupdate
--max-jobs, -j <n>       : Run n jobs in parallel
--mirror, -m <url>       : set mirror
--cache, -c <dir>        : set cache
--file, -f <file>        : read package names from file
--noupdate, -u           : don't update setup.ini from mirror
--ipv4, -4               : wget prefer ipv4
--help
--version"
}

version () {
  printf "apt-cyg version 0.57
Written by Stephen Jungels
Copyright (c) 2005-9 Stephen Jungels.  Released under the GPL."
}

current_cygarch () {
  arch | sed -e 's/^i686$/x86/g'
}

mirror_to_mirrordir () {
  echo "$1" | sed -e "s/:/%3a/g" -e "s:/:%2f:g"
}

findworkspace () {
  # default working directory, mirror and architecture

  mirror=ftp://mirror.mcs.anl.gov/pub/cygwin
  arch="$(current_cygarch)"
  cache=/setup
  
  # work wherever setup worked last, if possible
  
  if [ -e /etc/setup/last-cache ]; then
    cache="$(cygpath -au "$(head -1 /etc/setup/last-cache)")"
  fi
  cache="${cache%/}"
  
  if [ -e /etc/setup/last-mirror ]; then
    mirror="$(head -1 /etc/setup/last-mirror)"
  fi
  mirror="${mirror%/}"
  mirrordir="$(mirror_to_mirrordir "$mirror/")"
  
  echo Working directory is $cache
  echo Mirror is $mirror
  mkdir -p "$cache/$mirrordir/$arch"
  cd "$cache/$mirrordir/$arch"
  
  init_gnupg
  fetch_trustedkeys
}

download_and_verify () {
  "${WGET[@]}" -N "$1" || return 1
  [ -e "${1##*/}" ] || return 1
  if [ -z "$no_verify" ]; then
    "${WGET[@]}" -N "${1}.sig" || return 1
    [ -e "${1##*/}.sig" ] && verify_signatures "${1##*/}.sig" || { rm -f "${1##*/}" "${1##*/}.sig"; return 1; }
  fi
  return
}

files_backup () {
  locale file
  for file; do
    [ -e "${file}~" ] && mv    "${file}~" "${file}"
    [ -e "${file}"  ] && cp -a "${file}"  "${file}~"
  done
}

files_restore () {
  locale file
  for file; do
    [ -e "${file}"  ] && rm    "${file}"
    [ -e "${file}~" ] && mv    "${file}~" "${file}"
  done
}

files_backup_clean () {
  locale file
  for file; do
    [ -e "${file}~" ] && rm    "${file}~"
  done
}

setupini_download () {
  local BASEDIR="$cache/$mirrordir/$arch"
  mkdir -p "$BASEDIR" || { echo -e "\e[31;1mError:\e[30;0m mkdir \"$BASEDIR\" failed."; exit 1; }
  
  [ $noscripts -ne 0 -o $noupdate -ne 0 ] && return
  
  pushd "$BASEDIR"
  files_backup setup.ini setup.ini.sig setup.bz2 setup.bz2.sig
  
  while true; do
    download_and_verify "$mirror/$arch/setup.bz2" && { bunzip2 -k setup.bz2 && mv setup setup.ini || rm -f setup.bz2; }
    download_and_verify "$mirror/$arch/setup.ini" || break
    files_backup_clean setup.ini setup.ini.sig setup.bz2 setup.bz2.sig
    popd
    echo "Updated setup.ini"
    return
  done
  files_restore setup.ini setup.ini.sig setup.bz2 setup.bz2.sig
  popd
  echo -e "\e[31;1mError:\e[30;0m updating setup.ini, reverting."
  return 1
}

getsetup () {
  setupini_download || return 1
}

checkpackages () {
  if [ $# -eq 0 ]; then
    echo Nothing to do, exiting
    exit 0
  fi
}

# Usage: getrootdir arch
getrootdir () {
  case "$1" in
    x86)    cygpath -u "$(< /proc/registry32/HKEY_LOCAL_MACHINE/SOFTWARE/Cygwin/setup/rootdir)" ;;
    x86_64) cygpath -u "$(< /proc/registry64/HKEY_LOCAL_MACHINE/SOFTWARE/Cygwin/setup/rootdir)" ;;
    *)      echo -e "\e[31;1mError:\e[30;0m unknown arch $1" >&2 ;;
  esac
}

# Usage: charch arch apt-cyg_parms ...
charch () {
  local rootdir
  if [ "$(current_cygarch)" != "$1" ]; then
    echo -e "\e[32;1mcharch to:\e[30;0m $1"
    rootdir="$(getrootdir "$1")"
    shift
    chroot "$rootdir" "$rootdir/bin/bash" -lc \
      'cd "$1"; shift ; "$0" "$@"' \
      "$(which "$0" | xargs cygpath -aml | xargs cygpath -u)" \
      "$(pwd        | xargs cygpath -aml | xargs cygpath -u)" \
      "$@"
    exit $?
  fi
}

init_gnupg () {
  [ -z "$GPG" ] && return
  export GNUPGHOME="$cache/.apt-cyg"
  if [ ! -d "$GNUPGHOME" ]; then
    if ! { mkdir -p "$GNUPGHOME" && chmod 700 "$GNUPGHOME"; } then
      echo -e "\e[31;1mError:\e[30;0m cannot initialize directory $GNUPGHOME"
      exit 1
    fi
  fi
  GPG_KEYRING=( --keyring pubring.gpg )
}

# Usage: __ask_user "question?" (optional recognition of YES_TO_ALL=true auto yes)
__ask_user () {
  while true; do
    [ -n "$2" ] && { local pmt="$2"; local def=; }
    [ -n "$2" ] || { local pmt="y/n";local def=; }
    $YES_TO_ALL && { local RPY=Y;local def=Y; }
    [ -z "$def" ] && { echo -ne "$1 ";read -p "[$pmt] " RPY; }
    [ -z "$RPY" ] && { local RPY=$def; }
    case "$RPY" in
      Y*|y*) return 0 ;;
      N*|n*) return 1 ;;
         1*) return 0 ;;
         2*) return 1 ;;
    esac
  done
}

# Reference:
# https://www.gnu.org/software/wget/manual/wget.html#Exit-Status
# Usage: wget_exitstatus EXITSTATUS
wget_exitstatus () {
  case $1 in
  0) printf "No problems occurred.";;
  1) printf "Generic error code.";;
  2) printf "Parse error?for instance, when parsing command-line options, the '.wgetrc' or '.netrc'...";;
  3) printf "File I/O error.";;
  4) printf "Network failure.";;
  5) printf "SSL verification failure.";;
  6) printf "Username/password authentication failure.";;
  7) printf "Protocol errors.";;
  8) printf "Server issued an error response.";;
  *) printf "Unknown errors.";;
  esac
}

# Usage: wget_return_case_md5sum returncode
wget_return_case_md5sum () {
  case "$1" in
    0) return 0 ;;
    1) echo "$LABEL: FAILED: Could not download $URL."; return 1 ;;
    5) echo "$LABEL: WARNING: The SSL certificate is invalid $URL."
       __ask_user "Continue regardless of invalid SSL certificate?" || return 1
       "${WGET[@]}" --no-check-certificate "$URL" -O "$FILE"
       return 0
    ;;
    8) echo "$LABEL: FAILED: 404 Not Found $URL." return 1 ;;
    *) echo -e "\e[31;1mError:\e[30;0m FATAL: wget returned unkown value"; return 1 ;;
  esac
}

# Usage: wget_and_check_md5sum label hash url file
wget_and_check_md5sum () {
  local LABEL="$1"
  local MD5="$2"
  local URL="$3"
  local FILE="$4"
  "${WGET[@]}" "$URL" -O "$FILE"
  wget_return_case_md5sum "$?" || return 1
  if ! { echo "$MD5 *$FILE" | md5sum -c >& /dev/null; } then
    echo "$LABEL: FAILED: MD5 hash is not match."
    return 2
  fi
  echo "$LABEL: OK"
}

fetch_trustedkeys () {
  [ -z "$GPG" ] && return
  local i
  local FILE="$(mktemp)"
  local FILE_LATEST="$(mktemp)"
  for i in "${TRUSTEDKEYS[@]}"; do
    local LABEL="TRUSTEDKEY_${i}"
    local MD5="$(eval echo "\$${LABEL}_MD5")"
    local FPR="$(eval echo "\$${LABEL}_FPR")"
    local URL="$(eval echo "\$${LABEL}_URL")"
    local URL_LATEST="$(eval echo "\$${LABEL}_URL_LATEST")"
    local CASE=""
    if [ -z "$force_fetch_trustedkeys" ] && { "${GPG[@]}" --fingerprint --with-colons | grep -q "$FPR"; } then
      continue
    fi
    if [ -n "$URL" ]; then
      wget_and_check_md5sum "$LABEL" "$MD5" "$URL" "$FILE"
      CASE+="$?"
    else
      CASE+="-"
    fi
    if [ -n "$URL_LATEST" ]; then
      wget_and_check_md5sum "$LABEL" "$MD5" "$URL_LATEST" "$FILE_LATEST"
      CASE+="$?"
    else
      CASE+="-"
    fi
    case "$CASE" in
      00|01|0-)
        "${GPG[@]}" --import "$FILE"
      ;;
      02)
        echo "Warning: ${LABEL} has been updated."
        "${GPG[@]}" --import "$FILE"
      ;;
      -0)
        "${GPG[@]}" --import "$FILE_LATEST"
      ;;
      10|20)
        echo -e "\e[31;1mError:\e[30;0m ${LABEL} has miss configuration."
        exit 1
      ;;
      11|1-|-1)
        echo -e "\e[31;1mError:\e[30;0m Could not download ${LABEL}."
        exit 1
      ;;
      12|-2)
        echo -e "\e[31;1mError:\e[30;0m ${LABEL} has been updated, maybe. But sometimes it may has been cracked. Be careful !!!"
        exit 1
      ;;
      21|22|2-)
        echo -e "\e[31;1mError:\e[30;0m ${LABEL} has been cracked, maybe"
        exit 1
      ;;
      --)
        echo -e "\e[31;1mError:\e[30;0m ${LABEL} has no URL."
        exit 1
      ;;
    esac
  done
  rm "$FILE" "$FILE_LATEST"
}

# Usage: verify_signatures files ...
verify_signatures () {
  while [ $# -gt 0 ]; do
    if ! "${GPGV[@]}" "${GPG_KEYRING[@]}" "$1"; then
      echo -e "\e[31;1mError:\e[30;0m BAD signature: $1"
      return 1
    fi
    shift
  done
}

__gnupg_notice () {
  [ -z "$GPG" ] && { 
    echo -e "\e[31;1mError:\e[30;0m GnuPG is not installed. Prease install gnupg package"
    return 1
  }
}

# Usage: apt_cyg_key_add pkey ...
apt_cyg_key_add () {
  __gnupg_notice || return 1
  local pkeys
  for pkey; do
    pkeys+=( "$(cygpath -a "$pkey" )" )
  done
  findworkspace
  for pkey in "${pkeys[@]}"; do
    "${GPG[@]}" --import "$pkey"
  done
}

# Usage: apt_cyg_key_add keyid ...
apt_cyg_key_del () {
  __gnupg_notice || return 1
  local keyid
  findworkspace
  for keyid; do
    "${GPG[@]}" --batch --yes --delete-key "$keyid"
  done
}

apt_cyg_key_list () {
  __gnupg_notice || return 1
  findworkspace
  "${GPG[@]}" --list-keys
}

apt_cyg_key_finger () {
  __gnupg_notice || return 1
  findworkspace
  "${GPG[@]}" --fingerprint
}

apt_cyg_pathof () {
  findworkspace >& /dev/null
  while [ "$#" -gt 0 ]; do
    case "$1" in
      cache)            echo "$cache" ;;
      mirror)           echo "$mirror" ;;
      mirrordir)        echo "$mirrordir" ;;
      cache/mirrordir)  echo "$cache/$mirrordir" ;;
      setup.ini)        echo "$cache/$mirrordir/$arch/setup.ini" ;;
      *)
        echo -e "\e[31;1mError:\e[30;0m in function $FUNCNAME: unknown parameter: $1"
        exit 1
    esac
    shift
  done
}

apt_cyg_upgrade_self () {
  local basedir="$(dirname "$(readlink -f "$(which "$0")")")"
  if [ ! -d "$basedir/.git" ]; then
    echo -e "\e[31;1mError:\e[30;0m apt-get is not under the git version control."
    exit 1
  fi
  pushd "$basedir"
  git pull -v
  popd
}

proxy_auto () {
  local proxy=$("${WGET[@]}" --no-proxy -q -O - wpad/wpad.dat \
  | grep PROXY \
  | sed -e 's/^.*PROXY\s*\([^"]*\).*$/http:\/\/\1/g')
  
  [ -n "$proxy" ] && proxy_set "$proxy"
}

# unclean
proxy_set () {
  export http_proxy="$1"
  export https_proxy="$1"
  export ftp_proxy="$1"
}

# unclean
proxy_unset () {
  export -n http_proxy
  export -n https_proxy
  export -n ftp_proxy
}

proxy_setup () {
  case "$OPT_PROXY" in
    auto)     proxy_auto  ;;
    inherit)              ;;
    none)     proxy_unset ;;
    *)
      proxy_set "$OPT_PROXY"
    ;;
  esac
}

# PACKAGE_DB is defined at package_db.cc in the cygwin-app setup.exe
# See blow:
# https://www.sourceware.org/cygwin-apps/setup.html
# https://sourceware.org/cgi-bin/cvsweb.cgi/setup/package_db.cc?cvsroot=cygwin-apps
PACKAGE_DB="/etc/setup/installed.db"

package_db-version_check () {
  local ver2hdr="INSTALLED.DB 2"
  if head -n1 "${PACKAGE_DB}" | grep -Fqvx "${ver2hdr}"; then
    echo -e "\e[33;1mWarning:\e[30;0m ${PACKAGE_DB} is not version 2. The first line is below:"
    echo -e "$(head -n1 "${PACKAGE_DB}")\n" >&2
    # The previous version of apt-cyg was not treat version header correctly.
    if grep -FHnx "${ver2hdr}" "${PACKAGE_DB}" >&2; then
      echo -e "The above line looks like version header, but it is not the first line.\n" >&2
    fi
  fi
}

# Usage: package_db-is_registered PKGNAME
package_db-is_registered () {
  package_db-version_check
  awk '
  $1 == PKGNAME && NF != 2 {found = 1; exit}
  END {exit !found}
  ' PKGNAME="$1" "${PACKAGE_DB}"
}

package_db-list () {
  package_db-version_check
  awk 'NF == 3 {print $1}' "${PACKAGE_DB}"
}

# Usage: package_db-register PKGNAME PKGFILE
package_db-register () {
  local work="/tmp/apt-cyg.$$.${PACKAGE_DB##*/}"
  package_db-version_check
  awk '
  register() {print PKGNAME " " PKGFILE " 0"; registered = 1;}
  !registered && PKGNAME < $1 && NF != 2 {register()}
  {print $0}
  END {if (!registered) register()}
  ' PKGNAME="$1" PKGFILE="$2" "${PACKAGE_DB}" > "${work}"
  mv "${PACKAGE_DB}" "${PACKAGE_DB}-save"
  mv "${work}"       "${PACKAGE_DB}"
}

# Usage: package_db-unregister PKGNAME
package_db-unregister () {
  local work="/tmp/apt-cyg.$$.${PACKAGE_DB##*/}"
  package_db-version_check
  awk '!(PKGNAME == $1 && NF != 2) {print $0}' PKGNAME="$1" "${PACKAGE_DB}" > "${work}"
  mv "${PACKAGE_DB}" "${PACKAGE_DB}-save"
  mv "${work}"       "${PACKAGE_DB}"
}

# Usage: join FS fields ...
join () {
  local FS="$1" field="" result="" sep=""
  shift
  for field; do
    result="$result$sep$field"
    sep="$FS"
  done
  echo "$result"
}

# abstrat it!
# Usage: dep_check DIR ROOTPKGS ...
# Parameters:
#   DIR is "depends" or "rdepends".
#   ROOTPKGS is root package names to check dependency.
# Return:
#   package_name available shallow_depth deep_depth
dep_check () {
  awk \
  '
    function min(x,y) {return x < y ? x : y}
    function max(x,y) {return x < y ? y : x}
    function update_result(dir, rootpkg, pkg, depth, _, i) {
      if (0 + result[rootpkg, pkg, "deep"]) {
        result[rootpkg, pkg, "shallow"] = min(depth, result[rootpkg, pkg, "shallow"]);
        result[rootpkg, pkg, "deep"]    = max(depth, result[rootpkg, pkg, "deep"]);
      } else {
        result[rootpkg, pkg, "deep"] = result[rootpkg, pkg, "shallow"] = depth;
        result[rootpkg, pkg, "available"] = 0 + available[pkg];
        result[rootpkg, result[rootpkg, "n"]++] = pkg;
        for (i = 0; i < dep[dir, pkg, "n"]; i++) {
          update_result(dir, rootpkg, dep[dir, pkg, i], depth + 1);
        }
      }
    }
    $1 == "@" {
      pkg = $2;
      available[pkg] = 1;
    }
    $1 == "requires:" {
      for (req = 2; req <= NF; req++) {
        dep["rdepends", $req, dep["rdepends", $req, "n"]++] = pkg;
        dep["depends" , pkg , dep["depends" , pkg , "n"]++] = $req;
      }
    }
    END {
      split(ROOTPKGS, rootpkgs, "\x1c");
      for (k in rootpkgs) {
        update_result(DIR, rootpkgs[k], rootpkgs[k], 1);
        for(i = 0; i < result[rootpkgs[k], "n"]; i++) {
          printf("%-40s %d\t%d\t%d\n",
            result[rootpkgs[k], i],
            result[rootpkgs[k], result[rootpkgs[k], i], "available"],
            result[rootpkgs[k], result[rootpkgs[k], i], "shallow"],
            result[rootpkgs[k], result[rootpkgs[k], i], "deep"]);
        }
      }
    }
  ' \
  DIR="$1" ROOTPKGS="$(join $'\x1c' "${@:2}")" "$(apt_cyg_pathof "setup.ini")" \
  | awk '
  function min(x,y) {return x < y ? x : y}
  function max(x,y) {return x < y ? y : x}
  {
    packages[$1] = pkg = $1;
    status[pkg, "available"] = $2;
    status[pkg, "shallow"  ] = 0 + status[pkg, "shallow"] == 0 ? $3 : min(status[pkg, "shallow"], $3);
    status[pkg, "deep"     ] = max(0 + status[pkg, "deep"], $4);
  }
  END {
    for (pkg in packages) {
      printf("%-40s %d\t%d\t%d\n",
        pkg,
        status[pkg, "available"],
        status[pkg, "shallow"],
        status[pkg, "deep"])
    }
  }
  ' | sort -nrk4
}

apt-cyg-depends () {
  local pkg
  printf "%-40s %s\t%s\t%s\n" "PKGNAME" "AVAIL" "SHALLOW" "DEEP"
  dep_check depends "$@"
}

apt-cyg-rdepends () {
  local pkg
  printf "%-40s %s\t%s\t%s\n" "PKGNAME" "AVAIL" "SHALLOW" "DEEP"
  dep_check rdepends "$@"
}

# abstract
apt_cyg_completion_install () {
  if [ ! -d "/etc/bash_completion.d" ]; then
    echo -e "\e[31;1mError:\e[30;0m /etc/bash_completion.d is not exist."
    exit 1
  fi
  if ! package_db-is_registered "bash-completion"; then
    echo -e "\e[31;1mError:\e[30;0m bash-completion is not installed."
    exit 1
  fi
  
  local SUBCMDS
  local OPTIONS
  local SCRIPTFILE="$(realpath "$(which apt-cyg)")"
  local SCRIPTDIR="${SCRIPTNAME%/*}"
  
  readarray -t -O ${#SUBCMDS[@]} SUBCMDS < <(grep "^function" "$SCRIPTFILE" | awk 'match($2, /apt-cyg-([-_0-9A-Za-z]+)/,m){print m[1]}')
  readarray -t -O ${#OPTIONS[@]} OPTIONS < <(
    awk '
    /^function *parse_args *\(\)/ {proc=1}
    /^} *# *\/parse_args( |$)/     {proc=0}
    proc && match($0, /^ *(-[^()*]+)\)/, m) {
      split(m[1], x, "|");
      for (i in x) print x[i];
    }
    ' "$SCRIPTFILE"
  )
cat <<-EOD > /etc/bash_completion.d/apt-cyg
# bash completion for apt-cyg

__apt-cyg () {
  local cur prev getsubcmd subcmd
  
  # Auto update for completion script.
  if [ -z "$OPT_COMPLETION_DISABLE_AUTOUPDATE" -a "$SCRIPTFILE" -nt "/etc/bash_completion.d/apt-cyg" ]; then
    apt-cyg completion-install >/dev/null 2>&1
    . /etc/bash_completion.d/apt-cyg
    __apt-cyg "$@"
    return
  fi
  
  _get_comp_words_by_ref -n : cur prev
  
  getsubcmd=( apt-cyg --completion-get-subcommand \$(echo "\${COMP_LINE}" | sed -r -e 's/^[^ \t]+//g' -e 's/[^ \t]+\$//g') )
  subcmd="\$( "\${getsubcmd[@]}" )"
  
  case "\$subcmd" in
    install|depends|rdepends|describe|find)
      COMPREPLY=( \$(awk '/^@ /{print \$2}' "$(apt-cyg pathof setup.ini)") )
      ;;
    remove)
      COMPREPLY=( \$(apt-cyg show 2>/dev/null) )
      ;;
    pathof)
      COMPREPLY=( cache mirror mirrordir cache/mirrordir setup.ini )
      ;;
    "")
      COMPREPLY=( "${SUBCMDS[*]}" )
      ;;
  esac
  case "\$prev" in
    --charch)
      COMPREPLY=( x86 x86_64 )
      ;;
    --cache|-c)
      COMPREPLY=( \$(compgen -d -- "\$cur") )
      ;;
    --mirror|-m)
      COMPREPLY=( \$(awk '/^[^ \t]+/{section=\$1}section=="mirrors-lst"&&match(\$0,/^[ \t]+([^;]+);/,m){print "\""m[1]"\""}' "/etc/setup/setup.rc") )
      ;;
    --file|-f)
      COMPREPLY=( \$(compgen -f -- "\$cur") )
      ;;
    --proxy|-p)
      COMPREPLY=( auto inherit none http:// )
      ;;
    *)
      COMPREPLY+=( "${OPTIONS[*]}" )
      ;;
  esac
  if [ -n "\$DEBUG_COMPLETION" ]; then
    echo
    echo "COMP_WORDBREAKS: \$COMP_WORDBREAKS"
    echo "getsubcmd: '\${getsubcmd[@]}'"
    echo "subcmd: '\${subcmd[@]}'"
    echo "COMP_LINE: '\${COMP_LINE}'"
    echo "cur: \$cur"
    echo "prev: \$prev"
    echo "COMP_WORDS: \${COMP_WORDS[@]}"
    echo
    echo -n "\${COMP_LINE}"
  fi
  COMPREPLY=( \$(compgen -W "\${COMPREPLY[*]}" -- "\$cur") )
  __ltrim_colon_completions "\$cur"
}
complete -F __apt-cyg apt-cyg
EOD
  touch -r "$SCRIPTFILE" "/etc/bash_completion.d/apt-cyg"
  echo "A bash completion /etc/bash_completion.d/apt-cyg is installed"
}

apt_cyg_completion_uninstall () {
  if [ ! -f /etc/bash_completion.d/apt-cyg ]; then
    echo -e "\e[31;1mError:\e[30;0m /etc/bash_completion.d/apt-cyg is not exist."
    exit 1
  fi
  rm /etc/bash_completion.d/apt-cyg
  echo "A bash completion /etc/bash_completion.d/apt-cyg is uninstalled"
}

apt_cyg_mirrors_list () {
  awk '
    /^[^ \t]+/ {section = $1}
    section=="mirrors-lst" && match($0, /^[ \t]+([^;]+);/, m) {print m[1]}
  ' "/etc/setup/setup.rc"
}

apt_cyg_benchmark_mirrors () {
  local mirror result exitcode
  for mirror; do
    result="$( { time wget -qO/dev/null -T3 -t 1 "${mirror%/}/$(current_cygarch)/setup.bz2"; } 2>&1 )"
    exitcode=$?
    if [ $exitcode -ne 0 ];then
      echo -e "\e[33;1mWarning:\e[30;0m benchmark failed with wget exitcode $exitcode: $(wget_exitstatus $exitcode): $1" >&2
      continue
    fi
    echo -e "$(echo "$result" | grep real | cut -f 2 | tr -d "\n")\t${mirror}"
  done
}

apt_cyg_benchmark_parallel_mirrors () {
  local result="$(mktemp "${SCRIPTNAME}.$$.XXXXX")"
  local mirror
  for mirror; do echo $mirror; done | lesser_parallel apt_cyg_benchmark_mirrors {} | tee "$result"
  echo Finished benchmark.
  echo ========================================
  echo Sorted result.
  sort -rV "$result"
  rm "$result"
}

apt_cyg_benchmark_parallel_mirrors-list () {
  local mirrors
  readarray -t mirrors < <(apt_cyg_mirrors_list)
  apt_cyg_benchmark_parallel_mirrors "${mirrors[@]}"
}

# Lesser Parallel for Embedding
# Copyright (c) 2014 Koichi OKADA. All rights reserved.
# The official repository is:
# https://github.com/kou1okada/lesser_parallel
# This script is distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

LESSER_PARALLEL_MAX_JOBS=${LESSER_PARALLEL_MAX_JOBS:-8}

lesser_parallel_get_jobs_count () {
  jobs -l >/dev/null
  jobs -l | wc -l
}

# Usage: lesser_parallel_restrict_jobs_count MAXJOBS
lesser_parallel_restrict_jobs_count () {
  while [ $(lesser_parallel-get-jobs-count) -ge $1 ]; do
    sleep 0.2
  done
}

# Usage: lesser_parallel [command [arguments]] < list_ot_arguments
lesser_parallel () {
  local cmd arg lines line basename ext PARALLEL_SEQ=1
  readarray -t lines
  for line in "${lines[@]}"; do
    basename="$(basename "$line")"
    ext="${basename##*.}"
    [ "$ext" = "$basename" ] && ext=""
    [ "$ext" != "" ] && ext=".$ext"
    cmd=( )
    for arg; do
      case "$arg" in
      "{}")
        cmd+=( "$line" )
        ;;
      "{.}")
        cmd+=( "$(basename "$line" "$ext")" )
        ;;
      "{/}")
        cmd+=( "$basename" )
        ;;
      "{//}")
        cmd+=( "$(dirname "$line")" )
        ;;
      "{/.}")
        cmd+=( "$(basename "$basename" "$ext")" )
        ;;
      "{#}")
        cmd+=( "$PARALLEL_SEQ" )
        ;;
      *)
        cmd+=( "$arg" )
        ;;
      esac
    done
    lesser_parallel_restrict_jobs_count $LESSER_PARALLEL_MAX_JOBS
    "${cmd[@]}" &
    PARALLEL_SEQ=$[$PARALLEL_SEQ + 1]
  done
  lesser_parallel_restrict_jobs_count 1
}

# process options
noscripts=0
noupdate=0
OPT_FILES=()
SUBCOMMAND=""
ignore_case=""
force_remove=""
force_fetch_trustedkeys=""
no_verify=""
OPT_PROXY=${APT_CYG_PROXY:-auto}
YES_TO_ALL=false
INITIAL_ARGS=( "$@" )
ARGS=()

parse_args () {
local unknown_option
while [ $# -gt 0 ]; do
  case "$1" in
    --charch)
      OPT_CHARCH="$2"
      shift 2 || break
    ;;
    --use-setuprc)
      "$0" -c "$(grep -A1 last-cache  /etc/setup/setup.rc | tail -n1 | sed -r 's/^\s*|\s*$//g')" > /dev/null
      "$0" -m "$(grep -A1 last-mirror /etc/setup/setup.rc | tail -n1 | sed -r 's/^\s*|\s*$//g')" > /dev/null
      shift
    ;;
    --ignore-case|-i)
      ignore_case="$1"
      shift
    ;;
    --force-remove)
      force_remove=1
      shift
    ;;
    --force-fetch-trustedkeys)
      force_fetch_trustedkeys=1
      shift
    ;;
    --no-verify|-X)
      no_verify=1
      shift
    ;;
    --no-check-certificate)
      WGET+=( "--no-check-certificate" )
      shift
    ;;
    --proxy|-p)
      OPT_PROXY="$2"
      shift 2 || break
    ;;
    --completion-get-subcommand)
      OPT_COMPLETION_GET_SUBCOMMAND="$1"
      shift
    ;;
    --completion-disable-autoupdate)
      OPT_COMPLETION_DISABLE_AUTOUPDATE="$1"
      shift
    ;;
    --max-jobs|-j)
      LESSER_PARALLEL_MAX_JOBS="$2"
      shift 2 || break
    ;;
    --mirror|-m)
      OPT_MIRROR="$2"
      shift 2 || break
    ;;
    --cache|-c)
      OPT_CACHE="$2"
      shift 2 || break
    ;;
    --noscripts)
      noscripts=1
      shift
    ;;
    --noupdate|-u)
      noupdate=1
      shift
    ;;
    --ipv4|-4)
      WGET=( "${WGET[@]}" "--prefer-family=IPv4" )
      shift
    ;;
    --help)
      usage
      exit 0
    ;;
    --version)
      version
      exit 0
    ;;
    --file|-f)
      [ -n "$2" ] && OPT_FILES+=( "$2" )
      shift 2 || break
    ;;
    -*)
      unknown_option="$1"
      break
    ;;
    *)
      if [ -z "$SUBCOMMAND" ]; then
        SUBCOMMAND="$1"
      else
        ARGS+=( "$1" )
      fi
      shift
    ;;
  esac
done

[ -n "$OPT_COMPLETION_GET_SUBCOMMAND" ] && { echo "$SUBCOMMAND"; exit 0; }

[ -n "$unknown_option" ] && { echo -e "\e[31;1mError:\e[30;0m Unknown option: $unknown_option"; exit 1; }

[ $# -gt 0 ] && { echo -e "\e[31;1mError:\e[30;0m Number of parameters is not enough: $@"; exit 1; }

#/parse_args
parse_args "$@"

[ -n "$OPT_CHARCH" ] && charch "$OPT_CHARCH" "${INITIAL_ARGS[@]}"

[ "${#OPT_MIRROR[@]}" -gt 0 ] && echo "${OPT_MIRROR%/}/"             > /etc/setup/last-mirror
[ "${#OPT_CACHE[@]}"  -gt 0 ] && echo "$(cygpath -aw "$OPT_CACHE")"  > /etc/setup/last-cache

[ -z "$GPGV" -a -z "$no_verify" ] && {
  echo -e "\e[31;1mError:\e[30;0m GnuPG is not installed. Prease install gnupg package or use -X option."
  exit 1
}

for file in "${OPT_FILES[@]}"; do
  if [ -f "$file" ]; then
    readarray -t -O ${#ARGS[@]} ARGS < "$file"
  else
    echo "File $file not found, skipping"
  fi
done

apt_cyg_update () {
    findworkspace
    getsetup
}

apt_cyg_show () {
    echo 1>&2 "The following packages are installed:"
    package_db-list
}

apt_cyg_find () {
    local pkg
    checkpackages "$@"
    findworkspace
    getsetup
    for pkg do
      echo ""
      echo "Searching for installed packages matching $pkg:"
      package_db-list | awk '$1~query{print $1}' query="$pkg" IGNORECASE="$ignore_case"
      echo ""
      echo "Searching for installable packages matching $pkg:"
      awk -v query="$pkg" -v IGNORECASE="$ignore_case" \
        'BEGIN{RS="\n\n@ "; FS="\n"; ORS="\n"} {if ($1 ~ query) {print $1}}' \
        setup.ini
    done
}

apt_cyg_describe () {
    local pkg
    checkpackages "$@"
    findworkspace
    getsetup
    for pkg do
      echo ""
      awk -v query="$pkg" -v IGNORECASE="$ignore_case" \
        'BEGIN{RS="\n\n@ "; FS="\n"; ORS="\n"} {if ($1 ~ query) {print $0 "\n"}}' \
        setup.ini
    done
}

apt_cyg_packageof () {
    local pkg
    local manifest
    checkpackages "$@"
    for pkg do
      local key="$(which "$pkg" 2>/dev/null | sed "s:^/::")"
      if [ -z "$key" ]; then
        key="$pkg"
      fi
      for manifest in /etc/setup/*.lst.gz; do
        local found="$(gzip -cd "$manifest" | grep -c "$key")"
        if [ $found -gt 0 ]; then
          local package="$(echo $manifest | sed -e "s:/etc/setup/::" -e "s/.lst.gz//")"
          echo Found $key in the package $package
        fi
      done
    done
}

# abstract
apt_cyg_install () {
    local pkg
    local script
    checkpackages "$@"
    findworkspace
    getsetup
    for pkg do
      if package_db-is_registered "$pkg"; then
        echo "Package $pkg is already installed, skipping"
        continue
      fi
    echo ""
    echo "Installing $pkg"

    # look for package and save desc file
    mkdir -p "release/$pkg"
    awk > "release/$pkg/desc" -v package="$pkg" \
      'BEGIN{RS="\n\n@ "; FS="\n"} {if ($1 == package) {desc = $0; px++}} \
       END {if (px == 1 && desc != "") print desc; else print "Package not found"}' \
       setup.ini
    local desc="$(< "release/$pkg/desc")"
    if [ "$desc" = "Package not found" ]; then
      echo "Package $pkg not found or ambiguous name, exiting"
      rm -r "release/$pkg"
      exit 1 # return clean
    fi
    echo "Found package $pkg"

    # download and unpack the bz2 file
    # pick the latest version, which comes first
    local install="$(awk '/^install: / { print $2; exit }' "release/$pkg/desc")"
    if [ -z "$install" ]; then
      echo "Could not find \"install\" in package description: obsolete package?"
      exit 1
    fi
    local file="$(basename "$install")"
    cd "release/$pkg"
    "${WGET[@]}" -nc $mirror/$install
    
    # check the md5
    local digest="$(awk '/^install: / { print $4; exit }' "desc")"
    local digactual="$(md5sum $file | awk '{print $1}')"
    if [ "$digest" != "$digactual" ]; then
      echo "MD5 sum did not match, exiting"
      exit 1
    fi
    
    echo "Unpacking..."
    tar > "/etc/setup/$pkg.lst" xvf "$file" -C /
    gzip -f "/etc/setup/$pkg.lst"
    cd ../..
    
    # update the package database
    package_db-register "$pkg" "$file"
    
    # recursively install required packages
    local requires="$(grep "^requires: " "release/$pkg/desc" | sed -re 's/^requires: *(.*[^ ]) */\1/g' -e 's/ +/ /g')"
    local warn=0
    if [ -n "$requires" ]; then
      echo "Package $pkg requires the following packages, installing:"
      echo "$requires"
      for package in $requires; do
        if package_db-is_registered "$package"; then
          echo Package $package is already installed, skipping
          continue
        fi
        apt-cyg --proxy inherit --noscripts install $package
        [ $? -ne 0 ] && warn=1
      done
    fi
    [ "$warn" -ne 0 ] && echo "Warning: some required packages did not install, continuing"
   
    # run all postinstall scripts
    local pis="$(ls /etc/postinstall/*.sh 2>/dev/null | wc -l)"
    if [ "$pis" -gt 0 -a $noscripts -ne 1 ]; then
      echo "Running postinstall scripts"
      for script in /etc/postinstall/*.sh; do
        $script
        mv "$script" "$script.done"
      done
    fi
    echo "Package $pkg installed"
    done
}

apt_cyg_remove () {
    local pkg
    local req

    checkpackages "$@"
    for pkg do

      if ! package_db-is_registered "$pkg"; then
        echo "Package $pkg is not installed, skipping"
        continue
      fi

      local dontremove="cygwin coreutils gawk bzip2 tar xz wget bash"
      for req in $dontremove; do
        if [ "$pkg" = "$req" ]; then
          echo "apt-cyg cannot remove package $pkg, exiting"
          exit 1
        fi
      done

      if [ ! -e "/etc/setup/$pkg.lst.gz" -a -z "$force_remove" ]; then
        echo "Package manifest missing, cannot remove $pkg.  Exiting"
        exit 1
      fi
      echo "Removing $pkg"

      # run preremove scripts

      if [ -e "/etc/preremove/$pkg.sh" ]; then
        "/etc/preremove/$pkg.sh"
      fi

      gzip -cd "/etc/setup/$pkg.lst.gz" | awk '/[^\/]$/ {print "rm -f \"/" $0 "\""}' | sh
      rm -f "/etc/postinstall/$pkg.sh.done" "/etc/preremove/$pkg.sh" "/etc/setup/$pkg.lst.gz"
      package_db-unregister "$pkg"
      echo "Package $pkg removed"

    done
}

invoke_subcommand () {
    local SUBCOMMAND="${@:1:1}"
    local ARGS=( "${@:2}" )
    local ACTION="apt-cyg-${SUBCOMMAND:-help}"
    if type "$ACTION" >& /dev/null; then
      "$ACTION" "${ARGS[@]}"
    else
      echo -e "\e[31;1mError:\e[30;0m unknown subcommand: $SUBCOMMAND"
      return 1
    fi
}

proxy_setup
invoke_subcommand "$SUBCOMMAND" "${ARGS[@]}" || exit 1
